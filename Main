-- Boot the Rayfield Library with fallback and error handling
local function loadRayfield()
    local urls = {
        "https://sirius.menu/rayfield",
        -- Fallback mirror (public Rayfield source)
        "https://raw.githubusercontent.com/shlexware/Rayfield/main/source",
    }
    for _, url in ipairs(urls) do
        local ok, result = pcall(function()
            return loadstring(game:HttpGet(url))()
        end)
        if ok and result then
            return result
        end
    end
    return nil
end

local Rayfield = loadRayfield()
if not Rayfield then
    warn("SXYNA: Failed to load Rayfield from all sources. Your executor may be blocking HTTP or the sources are unavailable.")
    return
end

-- Roblox services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

-- Helpers
local function getHumanoid()
    local plr = Players.LocalPlayer
    if not plr then return nil end
    local char = plr.Character or plr.CharacterAdded:Wait()
    if not char then return nil end
    return char:FindFirstChildOfClass("Humanoid")
end

local function getHRP()
    local plr = Players.LocalPlayer
    if not plr then return nil end
    local char = plr.Character or plr.CharacterAdded:Wait()
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart")
end

-- Safe file helpers (executor-agnostic)
local function safeIsFile(path)
    local ok, res = pcall(function()
        if typeof(isfile) == "function" then
            return isfile(path)
        end
        return false
    end)
    return ok and res == true
end

local function safeIsFolder(path)
    local ok, res = pcall(function()
        if typeof(isfolder) == "function" then
            return isfolder(path)
        end
        return false
    end)
    return ok and res == true
end

local function safeReadFile(path)
    local ok, res = pcall(function()
        if typeof(readfile) == "function" then
            return readfile(path)
        end
        return nil
    end)
    if ok and type(res) == "string" and #res > 0 then return res end
    return nil
end

local function safeMakeFolder(path)
    pcall(function()
        if typeof(makefolder) == "function" and not safeIsFolder(path) then
            makefolder(path)
        end
    end)
end

local function safeWriteFile(path, content)
    pcall(function()
        if typeof(writefile) == "function" then
            local folder = path:match("^(.*)/[^/]+$") or path:match("^(.*)\\[^\\]+$")
            if folder and #folder > 0 then
                safeMakeFolder(folder)
            end
            writefile(path, content)
        end
    end)
end

-- Initialize theme from previous selection
local THEME_SAVE_PATH = "SXYNA/theme.txt"
local initialTheme = _G.SXYNA_THEME or (safeIsFile(THEME_SAVE_PATH) and safeReadFile(THEME_SAVE_PATH)) or "Bloom"

-- Create The Window
local Window = Rayfield:CreateWindow({
    Name = "SXYNA Universal Panel",
    Icon = nil,
    LoadingTitle = "SXYNA",
    LoadingSubtitle = "v1.0.1",
    ShowText = "SXYNA",
    Theme = initialTheme,

    Keybind = Enum.KeyCode.P, -- Some builds default to RightShift; we add P fallback below.

    DisableRayfieldPrompts = false,
    DisableBuildWarnings = true,

    ConfigurationSaving = {
        Enabled = true,
        FolderName = "SXYNA",
        FileName = "SXYNA",
    },

    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true,
    },

    KeySystem = true,
    KeySettings = {
        Title = "SXYNA Key System",
        Subtitle = "v1",
        Note = "To Get The Key, Join The Discord!",
        FileName = "SXYNAKEY",
        SaveKey = true,
        GrabKeyFromSite = false,
        Key = {"SXYNA-1.6.1.2.5"},
    }
})

pcall(function()
    if typeof(Rayfield.LoadConfiguration) == "function" then
        Rayfield:LoadConfiguration()
    end
end)

-- Fallback toggle for opening/closing the menu with P, regardless of build differences
local function toggleMenu()
    if typeof(Rayfield.Toggle) == "function" then
        Rayfield:Toggle()
    elseif typeof(Window.Toggle) == "function" then
        Window:Toggle()
    end
end

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.P then
        toggleMenu()
    end
end)

Rayfield:Notify({
    Title = "SXYNA",
    Content = "Press [P] or RightShift to open. Enter your key to unlock. Theme: " .. tostring(initialTheme),
    Duration = 5,
    Image = 4483362458,
})

-- Create The Tab[s]
local SettingsTab = Window:CreateTab("Settings", 4483362458)

-- Key Section
SettingsTab:CreateSection("Key")

SettingsTab:CreateInput({
    Name = "Toggle Key (info)",
    CurrentValue = "P",
    PlaceholderText = "Enter a key (info only)",
    RemoveTextAfterFocusLost = false,
    Flag = "KeyInfo",
    Callback = function(KeyInput)
        Rayfield:Notify({
            Title = "Toggle Key Changed.",
            Content = "To Open/Close The Menu Press [" .. tostring(KeyInput) .. "]",
            Duration = 6.5,
            Image = 4483362458,
         })
    end,
})

-- Theme Section
SettingsTab:CreateSection("Menu Theme")
local selectedTheme = initialTheme

SettingsTab:CreateDropdown({
    Name = "Menu Theme To Use?",
    Options = {"Default","AmberGlow","Amethyst","Bloom","DarkBlue","Green","Light","Ocean","Serenity"},
    CurrentOption = {initialTheme},
    MultipleOptions = false,
    Flag = "MenuTheme",
    Callback = function(MenuTheme)
        local theme = MenuTheme
        if typeof(MenuTheme) == "table" then
            theme = MenuTheme[1]
        end
        selectedTheme = theme
        _G.SXYNA_THEME = theme
        safeWriteFile(THEME_SAVE_PATH, tostring(theme))
    end,
})

SettingsTab:CreateButton({
    Name = "Set The Theme",
    Callback = function()
        Rayfield:Notify({
            Title = "Theme Selected",
            Content = "Selected theme: " .. tostring(selectedTheme) .. ". If it doesn't change immediately, restart the menu.",
            Duration = 6.5,
            Image = 4483362458,
        })
    end,
})

-- Player Tab
local PlayerTab = Window:CreateTab("Player", 4483362458)
PlayerTab:CreateSection("Player")

-- Player speed controls
local speedEnabled = false
local speedValue = 16
local speedConn = nil

local function applyDefaultSpeedOnce()
    local hum = getHumanoid()
    if hum then
        hum.WalkSpeed = 16
    end
end

local function startSpeedLoop()
    if speedConn then speedConn:Disconnect() speedConn = nil end
    speedConn = RunService.Heartbeat:Connect(function()
        if not speedEnabled then return end
        local hum = getHumanoid()
        if hum then
            hum.WalkSpeed = speedValue
        end
    end)
end

PlayerTab:CreateToggle({
    Name = "Speed Changer",
    CurrentValue = false,
    Flag = "PlayerSpeedT",
    Callback = function(enabled)
        speedEnabled = enabled
        if enabled then
            startSpeedLoop()
            local hum = getHumanoid()
            if hum then hum.WalkSpeed = speedValue end
        else
            if speedConn then speedConn:Disconnect() speedConn = nil end
            applyDefaultSpeedOnce()
        end
    end,
})

PlayerTab:CreateSlider({
    Name = "Speed To Change To",
    Range = {1, 1000},
    Increment = 1,
    Suffix = "walkspeed",
    CurrentValue = 16,
    Flag = "SpeedS",
    Callback = function(value)
        speedValue = value
        if speedEnabled then
            local hum = getHumanoid()
            if hum then hum.WalkSpeed = speedValue end
        end
    end,
})

-- Jump controls
local jumpEnabled = false
local jumpValue = 50
local jumpConn = nil

local function applyDefaultJumpOnce()
    local hum = getHumanoid()
    if hum then
        if hum.UseJumpPower ~= nil then
            hum.UseJumpPower = true
            hum.JumpPower = 50
        else
            hum.JumpHeight = 7.2
        end
    end
end

local function applyJump(value)
    local hum = getHumanoid()
    if hum then
        if hum.UseJumpPower ~= nil then
            hum.UseJumpPower = true
            hum.JumpPower = value
        else
            hum.JumpHeight = math.clamp(value / 7, 1, 50)
        end
    end
end

local function startJumpLoop()
    if jumpConn then jumpConn:Disconnect() jumpConn = nil end
    jumpConn = RunService.Heartbeat:Connect(function()
        if not jumpEnabled then return end
        applyJump(jumpValue)
    end)
end

PlayerTab:CreateToggle({
    Name = "Jump Power",
    CurrentValue = false,
    Flag = "PlayerJumpT",
    Callback = function(enabled)
        jumpEnabled = enabled
        if enabled then
            startJumpLoop()
            applyJump(jumpValue)
        else
            if jumpConn then jumpConn:Disconnect() jumpConn = nil end
            applyDefaultJumpOnce()
        end
    end,
})

PlayerTab:CreateSlider({
    Name = "Jump Power Value",
    Range = {0, 500},
    Increment = 1,
    Suffix = "jumppower",
    CurrentValue = 50,
    Flag = "JumpS",
    Callback = function(value)
        jumpValue = value
        if jumpEnabled then
            applyJump(jumpValue)
        end
    end,
})

-- Noclip
local noclipEnabled = false
local noclipConn
local function setCharacterCollision(enabled)
    local plr = Players.LocalPlayer
    if not plr then return end
    local char = plr.Character
    if not char then return end
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = enabled and true or false
        end
    end
end

local function startNoclip()
    if noclipConn then noclipConn:Disconnect() noclipConn = nil end
    noclipConn = RunService.Stepped:Connect(function()
        if not noclipEnabled then return end
        setCharacterCollision(false)
    end)
end

PlayerTab:CreateToggle({
    Name = "Noclip",
    CurrentValue = false,
    Flag = "PlayerNoclipT",
    Callback = function(enabled)
        noclipEnabled = enabled
        if enabled then
            startNoclip()
            setCharacterCollision(false)
        else
            if noclipConn then noclipConn:Disconnect() noclipConn = nil end
            setCharacterCollision(true)
        end
    end,
})

-- Fly (fixed: uses AssemblyLinearVelocity for reliable movement)
local flyEnabled = false
local flySpeed = 50
local flyConn
local keys = {W=false,S=false,A=false,D=false,Space=false,Shift=false}

local function dirFromKeys()
    local cam = workspace.CurrentCamera
    if not cam then return Vector3.zero end
    local move = Vector3.zero
    if keys.W then move = move + cam.CFrame.LookVector end
    if keys.S then move = move - cam.CFrame.LookVector end
    if keys.A then move = move - cam.CFrame.RightVector end
    if keys.D then move = move + cam.CFrame.RightVector end
    if keys.Space then move = move + Vector3.new(0,1,0) end
    if keys.Shift then move = move + Vector3.new(0,-1,0) end
    if move.Magnitude > 0 then move = move.Unit end
    return move
end

local function setKey(k, v)
    if keys[k] ~= nil then keys[k] = v end
end

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    local kc = input.KeyCode
    if kc == Enum.KeyCode.W then setKey('W', true)
    elseif kc == Enum.KeyCode.S then setKey('S', true)
    elseif kc == Enum.KeyCode.A then setKey('A', true)
    elseif kc == Enum.KeyCode.D then setKey('D', true)
    elseif kc == Enum.KeyCode.Space then setKey('Space', true)
    elseif kc == Enum.KeyCode.LeftShift or kc == Enum.KeyCode.RightShift then setKey('Shift', true)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    local kc = input.KeyCode
    if kc == Enum.KeyCode.W then setKey('W', false)
    elseif kc == Enum.KeyCode.S then setKey('S', false)
    elseif kc == Enum.KeyCode.A then setKey('A', false)
    elseif kc == Enum.KeyCode.D then setKey('D', false)
    elseif kc == Enum.KeyCode.Space then setKey('Space', false)
    elseif kc == Enum.KeyCode.LeftShift or kc == Enum.KeyCode.RightShift then setKey('Shift', false)
    end
end)

local function startFly()
    local hum = getHumanoid()
    local hrp = getHRP()
    if not hum or not hrp then return end

    -- Put character in physics mode, disable collisions for smoother flight
    hum.PlatformStand = true
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    setCharacterCollision(false)

    if flyConn then flyConn:Disconnect() flyConn = nil end
    flyConn = RunService.Heartbeat:Connect(function()
        if not flyEnabled then return end
        local dir = dirFromKeys()
        if hrp and dir then
            -- Move reliably using AssemblyLinearVelocity
            hrp.AssemblyLinearVelocity = dir * flySpeed
        end
    end)
end

local function stopFly()
    local hum = getHumanoid()
    local hrp = getHRP()
    if flyConn then flyConn:Disconnect() flyConn = nil end
    if hrp then
        hrp.AssemblyLinearVelocity = Vector3.zero
    end
    if hum then
        hum.PlatformStand = false
        -- Re-enable normal collisions if noclip isn't on
        if not noclipEnabled then setCharacterCollision(true) end
    end
end

PlayerTab:CreateToggle({
    Name = "Fly",
    CurrentValue = false,
    Flag = "PlayerFlyT",
    Callback = function(enabled)
        flyEnabled = enabled
        if enabled then
            startFly()
        else
            stopFly()
        end
    end,
})

PlayerTab:CreateSlider({
    Name = "Fly Speed",
    Range = {10, 300},
    Increment = 5,
    Suffix = "stud/s",
    CurrentValue = 50,
    Flag = "FlySpeedS",
    Callback = function(value)
        flySpeed = value
    end,
})

-- Player Camera
PlayerTab:CreateSection("Player Camera")

local function getCamera()
    return workspace.CurrentCamera
end

local DEFAULT_FOV = 70
local baselineFov = (getCamera() and getCamera().FieldOfView) or DEFAULT_FOV

PlayerTab:CreateSlider({
    Name = "Field of View",
    Range = {40, 120},
    Increment = 1,
    Suffix = "deg",
    CurrentValue = baselineFov,
    Flag = "FOVSlider",
    Callback = function(value)
        local cam = getCamera()
        if cam then
            cam.FieldOfView = value
        end
    end,
})

PlayerTab:CreateButton({
    Name = "Reset FOV",
    Callback = function()
        local cam = getCamera()
        if cam then
            cam.FieldOfView = baselineFov or DEFAULT_FOV
            Rayfield:Notify({
                Title = "FOV Reset",
                Content = "FOV set to " .. tostring(baselineFov or DEFAULT_FOV),
                Duration = 3,
                Image = 4483362458,
            })
        end
    end,
})

-- Teleport & Fun
local TeleportTab = Window:CreateTab("Teleport & Fun", 4483362458)
TeleportTab:CreateSection("Players")

-- Players Dropdown and Teleports
local selectedPlayerName = nil

local function listOtherPlayers()
    local names = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= Players.LocalPlayer then table.insert(names, plr.Name) end
    end
    table.sort(names)
    return names
end

local PlayerDropdown
local function setSelectedNameFromCallback(val)
    if typeof(val) == "table" then
        selectedPlayerName = val[1]
    else
        selectedPlayerName = val
    end
end

local function refreshPlayersDropdown()
    local options = listOtherPlayers()
    if PlayerDropdown and typeof(PlayerDropdown.Set) == "function" then
        PlayerDropdown:Set(options)
    end
    -- Clear selection if it no longer exists
    if selectedPlayerName and not Players:FindFirstChild(selectedPlayerName) then
        selectedPlayerName = nil
    end
end

PlayerDropdown = TeleportTab:CreateDropdown({
    Name = "Select Player",
    Options = listOtherPlayers(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "TPPlayerSelect",
    Callback = function(name)
        setSelectedNameFromCallback(name)
    end,
})

TeleportTab:CreateButton({
    Name = "Refresh Players",
    Callback = function()
        refreshPlayersDropdown()
        Rayfield:Notify({
            Title = "Players Refreshed",
            Content = "Updated player list.",
            Duration = 2,
            Image = 4483362458,
        })
    end,
})

-- Auto-refresh when players join/leave
Players.PlayerAdded:Connect(refreshPlayersDropdown)
Players.PlayerRemoving:Connect(refreshPlayersDropdown)

TeleportTab:CreateButton({
    Name = "Teleport To Selected",
    Callback = function()
        local me = Players.LocalPlayer
        if not me or not me.Character then return end
        if not selectedPlayerName then return end
        local target = Players:FindFirstChild(selectedPlayerName)
        if not target or not target.Character then return end
        local myHRP = me.Character:FindFirstChild("HumanoidRootPart")
        local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
        if myHRP and tHRP then
            myHRP.CFrame = tHRP.CFrame * CFrame.new(0, 0, -2)
        end
    end,
})

TeleportTab:CreateButton({
    Name = "Teleport Random",
    Callback = function()
        local candidates = {}
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= Players.LocalPlayer then table.insert(candidates, plr) end
        end
        if #candidates == 0 then return end
        local target = candidates[math.random(1, #candidates)]
        local me = Players.LocalPlayer
        if not me or not me.Character or not target.Character then return end
        local myHRP = me.Character:FindFirstChild("HumanoidRootPart")
        local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
        if myHRP and tHRP then
            myHRP.CFrame = tHRP.CFrame * CFrame.new(0, 0, -2)
        end
    end,
})

-- Orbit Player (smoother and consistent)
TeleportTab:CreateSection("Orbit Player")
local orbitEnabled = false
local orbitConn
local orbitSpeed = 90 -- deg/sec
local orbitDistance = 8
local orbitHeight = 3

TeleportTab:CreateSlider({
    Name = "Orbit Speed",
    Range = {0, 720},
    Increment = 5,
    Suffix = "deg/s",
    CurrentValue = orbitSpeed,
    Flag = "OrbitSpeedS",
    Callback = function(v) orbitSpeed = v end,
})

TeleportTab:CreateSlider({
    Name = "Orbit Distance",
    Range = {1, 50},
    Increment = 1,
    Suffix = "studs",
    CurrentValue = orbitDistance,
    Flag = "OrbitDistS",
    Callback = function(v) orbitDistance = v end,
})

TeleportTab:CreateSlider({
    Name = "Orbit Height",
    Range = {0, 30},
    Increment = 1,
    Suffix = "studs",
    CurrentValue = orbitHeight,
    Flag = "OrbitHeightS",
    Callback = function(v) orbitHeight = v end,
})

local function startOrbit()
    if orbitConn then orbitConn:Disconnect() orbitConn = nil end
    local angle = 0
    orbitConn = RunService.Heartbeat:Connect(function(dt)
        if not orbitEnabled then return end
        local me = Players.LocalPlayer
        local target = selectedPlayerName and Players:FindFirstChild(selectedPlayerName)
        if not me or not me.Character or not target or not target.Character then return end
        local myHRP = me.Character:FindFirstChild("HumanoidRootPart")
        local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
        if not (myHRP and tHRP) then return end

        -- Keep collisions off while orbiting for smooth motion
        setCharacterCollision(false)

        angle = (angle + math.rad(orbitSpeed) * dt) % (math.pi * 2)
        local offset = Vector3.new(math.cos(angle) * orbitDistance, orbitHeight, math.sin(angle) * orbitDistance)
        local goalCFrame = CFrame.new(tHRP.Position + offset, tHRP.Position)

        -- Directly set CFrame; optionally you can tween if you want smoother easing:
        myHRP.CFrame = goalCFrame
        -- Zero out linear velocity to avoid physics fighting the set CFrame
        myHRP.AssemblyLinearVelocity = Vector3.zero
    end)
end

TeleportTab:CreateToggle({
    Name = "Orbit Selected Player",
    CurrentValue = false,
    Flag = "OrbitPlayerT",
    Callback = function(enabled)
        orbitEnabled = enabled
        if enabled then
            startOrbit()
        else
            if orbitConn then orbitConn:Disconnect() orbitConn = nil end
            if not noclipEnabled then setCharacterCollision(true) end
        end
    end,
})

-- Fling Player (spin self really fast to fling target upon collision)
local function flingSelectedPlayer()
    local me = Players.LocalPlayer
    if not me or not me.Character then return end
    if not selectedPlayerName then return end
    local target = Players:FindFirstChild(selectedPlayerName)
    if not target or not target.Character then return end

    local myHRP = me.Character:FindFirstChild("HumanoidRootPart")
    local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
    local hum = getHumanoid()
    if not (myHRP and tHRP and hum) then return end

    -- Ensure collisions ON for fling to transfer momentum
    setCharacterCollision(true)

    -- Move close to target
    myHRP.CFrame = tHRP.CFrame * CFrame.new(0, 0, -2)

    -- Add a temporary AngularVelocity to spin fast
    local att = myHRP:FindFirstChildWhichIsA("Attachment") or Instance.new("Attachment", myHRP)
    local av = Instance.new("AngularVelocity")
    av.Attachment0 = att
    av.MaxTorque = math.huge
    av.AngularVelocity = Vector3.new(0, 300, 0) -- spin around Y rapidly
    av.Parent = myHRP

    -- Also add forward linear velocity burst into the target
    myHRP.AssemblyLinearVelocity = (tHRP.Position - myHRP.Position).Unit * 200

    -- Run for a short duration, then cleanup
    task.delay(1.25, function()
        if av then av:Destroy() end
        -- Optionally restore noclip state
        if noclipEnabled then
            setCharacterCollision(false)
        end
    end)
end

TeleportTab:CreateButton({
    Name = "Fling Selected Player",
    Callback = function()
        flingSelectedPlayer()
    end,
})
